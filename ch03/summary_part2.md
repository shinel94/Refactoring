### 14. 성의 없는 요소 / Lazy Element
> 모든 코드는 프로그램 요소 (함수, 메서드, 클래스, 인터페이스 등)이 나타나게 코드를 작성해야 한다. <br>
> 리팩터링 등의 이유로 프로그램 요소가 생략된 코드는 최대한 제거하는 것이 좋다.
>> 1) 함수 / 클래스 인라인 하기 <br>
>> 2) 상속 구조 계층 합치기 <br>
### 15. 추측성 일반화 / Speculative Generality
> '나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드를 나타내는 말 <br>
> 이런 코드가 많아지면 오히려 이해하기가 힘들어 지고 관리도 힘들어 진다. <br>
> 미래에 쓰이면 다행이지만 대부분의 경우 걸리적 거리는 낭비일 뿐이기 때문에 최대한 제거하는 것이 좋다.
>> 1) 계층 합치기 : 불필요한 추상 클래스 제거
>> 2) 함수 / 클래스 인라인하기
>> 3) 함수 선언 바꾸기 : 불필요한 매개변수 제거
>> 4) 죽은 코드 제거하기 : 오로지 테스트 코드에서만 사용하는 함수 또는 클래스 제거
### 16. 임시 필드 / Temporary Field
> 객체의 모든 필드는 항상 값으로 할당이 되어 있어져야 하는데,  <br>
> 특정 경우에만 사용하는 임시 필드는 추후 코드 이해를 힘들게 만드는 요소가 된다.
>> 1) 클래스 추출하기 : 독립되어 있는 필드를 추출해서 빼낸다.
>> 2) 함수 옮기기 : 임시 필드와 관련된 코드를 추출해서 빼낸다.
>> 3) 특이 케이스 추가 하기 : 필드들이 유요하지 않을 때를 위한 대안 클래스를 생성해서 제거
### 17. 메시지 체인 / Message Chains
> 클라이언트가 한 객체를 통해서 다른 객체를 얻은 뒤 방금 얻은 객체에 또다른 객체를 요청하는 식(파이프 라인) <br>
> 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드
>> 1) 위임 숨기기 : 메세지 체인을 보이는 연결점에 적용할 수 있으나, 모든 중간객체가 모두 중개자가 되어 버릴 수 있기 때문에 최종 결과 객체의 용도에 따라서 적용 여부를 결정 하는 것이 좋다.
>> 2) 함수 추출하기 / 함수 옮기기 : 결과 객체를 사용하는 코드를 빼내서 체인을 옮겨 숨길 수 있는지 확인 
### 18. 중개자 / Middle Man
> 외부로부터 세부사항을 숨겨주는 캡슐화가 있고, 그를 진행하는 과정에서 위임이 자주 활용 된다. <br>
> 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면, 제거하는 것이 좋다,
>> 1) 중개자 제거하기 : 실제로 일을 하는 객체와 직접 소통을 하기 해서 지나친 중개자를 제거한다.
### 19. 내부자 거래 / Insider Trading
> 모듈 사이의 데이터 이동이 많으면 모듈간 커플링이 심해지기 때문에 <br>
> 이동 또는 통신을 최소화 하고 투명하게 처리하는 것이 좋다.
>> 1) 함수 옮기기 / 필드 옮기기 : 사적으로 처리 되는 부분을 투명하게 처리 하도록 변경
>> 2) 위임 숨기기 : 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 모듈을 만들어서 다른 모듈이 중간자 역할을 하게 한다.
>> 3) 서브 클래스 / 슈퍼 클래스를 위임으로 바꾸기 : 부모 자식 간 클래스 사이에 결탁 독립이 필요해 질때 적용
### 20. 거대한 클래스 / Large Class
> 단일 클래스가 수행하는 일이 너무 많고, 필드가 너무 많은 경우
> 중복 코드가 발생하기 쉽기 때문에 지나치게 큰 클래스는 지양하는 것이 좋다.
>> 1) 클래스 추출하기 : 클래스의 다양한 필드들을 특정 행동들에 따라서 다른 클래스로 추출
>> 2) 슈퍼클래스 추출하기 : 공통 기능들을 상속관계로 정리하여 기능 추출
>> 3) 타입 코드를 서브클래스로 바꾸기 : 슈퍼클래스 추출하기와 반대로 기능을 쪼개서 다른 객체로 관리
### 21. 서로 다른 인터페이스의 대안 클래스들 / Alternative Classes with Different Interface
> 클래스를 사용할 때 큰 장점은 필요에 따라 인터페이스가 동일한 객체들을 <br>
> 손 쉽게 교채해서 사용할 수 있다는 것이다.
>> 1) 함수 선언 바꾸기 / 함수 옮기기 : 인터페이스가 같아질 때 까지 동작들을 클래스 안으로 밀어넣거나 시그니쳐를 일치 시킨다.
>> 2) 슈퍼클래스 추출하기 : 대안 클래스들 사이에 중복코드를 슈퍼클래스로 추출하여 관리
### 22. 데이터 클래스 / Data Class
> 데이터 필드와 게터/세터 메서드로만 구성된 클래스 <br>
> 해당 객체에 public으로 사용되는 필드가 있다면 숨기거나 제거하는 것이 좋다. <br>
> 중간 결과를 담는 객체로 많이 사용되는데, 데이터가 Immutable이라면 캡슐화 하지 않고 필드 자체에 접근할 수 있도록 해도 무방하다.
>> 1) 레코드 캡슐화하기 : public 변수를 숨길 수 있다.
>> 2) 세터 제거하기 : 접근을 완전히 차단해 값이 오염되는 것을 막는다.
### 23. 상속 포기 / Refused Bequest
> 부모 클래스가 가지고 있는 것들 중 일부분만 상속 받으려는 경우는 클래스 계층 구조를 변경하는 것이 좋다. <br>
>> 1) 메서드 내리기 / 필드 내리기 : 상속받지 않을 코드를 모조리 서브클래스로 넘기고 부모클래스에는 고통된 부분만 남도록 한다.
>> 2) 서브클래스 / 슈퍼클래스를 위임으로 바꾸기 : 부모클래스의 동작은 필요로 하지 않을 수 있지만, 인터페이스는 반드시 따라야 하고, 이런 상속메커니즘을 위임으로 벗어날 수 있다.
### 24. 주석 / Comment
> 주석이 장황하게 달린 원인은 코드 작성이 잘못 되었을 확률이 높다. <br>
> 주석이 많은 것은 리팩터링을 진행해야할 코드가 많다는 단서일 수 있다. <br>
> 주석을 남겨야 겠다는 생각이 들면, 가장 먼저 수석이 필요없는 코드로 리팩터링 하는 것이 좋다. <br>
> 뭘 할지 모를 때, 현재 진행 상황뿐만 아니라 확실하지 않은 부분에 대해서 주석에 남겨 <br>
> 나중에 수정 작업에 도움이 될 수 있다.
>> 1) 함수 추출하기 : 함수의 기능에 대한 코멘트가 있다면 적용하는 것이 좋다.
>> 2) 함수 선언 바꾸기 : 함수 이름을 바꾸어서 설명을 명확하게 할 수 있다.
>> 3) 어서션 추가하기 : 시스템이 동작하기 위한 선행조건을 명시하여 코드를 명확하게 한다.